<<<<<<< HEAD
const path = require('path');
const bindings = require('node-gyp-build')(path.resolve(__dirname));

const crypto = require('crypto');

const promises = require('./promises');
=======
'use strict';

var nodePreGyp = require('@mapbox/node-pre-gyp');
var path = require('path');
var binding_path = nodePreGyp.find(path.resolve(path.join(__dirname, './package.json')));
var bindings = require(binding_path);

var crypto = require('crypto');

var promises = require('./promises');
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2

/// generate a salt (sync)
/// @param {Number} [rounds] number of rounds (default 10)
/// @return {String} salt
<<<<<<< HEAD
function genSaltSync(rounds, minor) {
=======
module.exports.genSaltSync = function genSaltSync(rounds, minor) {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
    // default 10 rounds
    if (!rounds) {
        rounds = 10;
    } else if (typeof rounds !== 'number') {
        throw new Error('rounds must be a number');
    }

<<<<<<< HEAD
    if (!minor) {
        minor = 'b';
    } else if (minor !== 'b' && minor !== 'a') {
=======
    if(!minor) {
        minor = 'b';
    } else if(minor !== 'b' && minor !== 'a') {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
        throw new Error('minor must be either "a" or "b"');
    }

    return bindings.gen_salt_sync(minor, rounds, crypto.randomBytes(16));
<<<<<<< HEAD
}
=======
};
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2

/// generate a salt
/// @param {Number} [rounds] number of rounds (default 10)
/// @param {Function} cb callback(err, salt)
<<<<<<< HEAD
function genSalt(rounds, minor, cb) {
    let error;

    // if callback is first argument, then use defaults for others
    if (typeof arguments[0] === 'function') {
        // have to set callback first otherwise arguments are overridden
        cb = arguments[0];
        rounds = 10;
        minor = 'b';
        // callback is second argument
    } else if (typeof arguments[1] === 'function') {
        // have to set callback first otherwise arguments are overridden
=======
module.exports.genSalt = function genSalt(rounds, minor, cb) {
    var error;

    // if callback is first argument, then use defaults for others
    if (typeof arguments[0] === 'function') {
        // have to set callback first otherwise arguments are overriden
        cb = arguments[0];
        rounds = 10;
        minor = 'b';
    // callback is second argument
    } else if (typeof arguments[1] === 'function') {
        // have to set callback first otherwise arguments are overriden
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
        cb = arguments[1];
        minor = 'b';
    }

    if (!cb) {
        return promises.promise(genSalt, this, [rounds, minor]);
    }

    // default 10 rounds
    if (!rounds) {
        rounds = 10;
    } else if (typeof rounds !== 'number') {
        // callback error asynchronously
        error = new Error('rounds must be a number');
<<<<<<< HEAD
        return process.nextTick(function () {
=======
        return process.nextTick(function() {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
            cb(error);
        });
    }

<<<<<<< HEAD
    if (!minor) {
        minor = 'b'
    } else if (minor !== 'b' && minor !== 'a') {
        error = new Error('minor must be either "a" or "b"');
        return process.nextTick(function () {
=======
    if(!minor) {
        minor = 'b'
    } else if(minor !== 'b' && minor !== 'a') {
        error = new Error('minor must be either "a" or "b"');
        return process.nextTick(function() {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
            cb(error);
        });
    }

<<<<<<< HEAD
    crypto.randomBytes(16, function (error, randomBytes) {
=======
    crypto.randomBytes(16, function(error, randomBytes) {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
        if (error) {
            cb(error);
            return;
        }

        bindings.gen_salt(minor, rounds, randomBytes, cb);
    });
<<<<<<< HEAD
}
=======
};
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2

/// hash data using a salt
/// @param {String|Buffer} data the data to encrypt
/// @param {String} salt the salt to use when hashing
/// @return {String} hash
<<<<<<< HEAD
function hashSync(data, salt) {
=======
module.exports.hashSync = function hashSync(data, salt) {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
    if (data == null || salt == null) {
        throw new Error('data and salt arguments required');
    }

    if (!(typeof data === 'string' || data instanceof Buffer) || (typeof salt !== 'string' && typeof salt !== 'number')) {
        throw new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');
    }

    if (typeof salt === 'number') {
        salt = module.exports.genSaltSync(salt);
    }

    return bindings.encrypt_sync(data, salt);
<<<<<<< HEAD
}
=======
};
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2

/// hash data using a salt
/// @param {String|Buffer} data the data to encrypt
/// @param {String} salt the salt to use when hashing
/// @param {Function} cb callback(err, hash)
<<<<<<< HEAD
function hash(data, salt, cb) {
    let error;

    if (typeof data === 'function') {
        error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');
        return process.nextTick(function () {
=======
module.exports.hash = function hash(data, salt, cb) {
    var error;

    if (typeof data === 'function') {
        error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');
        return process.nextTick(function() {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
            data(error);
        });
    }

    if (typeof salt === 'function') {
        error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');
<<<<<<< HEAD
        return process.nextTick(function () {
=======
        return process.nextTick(function() {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
            salt(error);
        });
    }

    // cb exists but is not a function
    // return a rejecting promise
    if (cb && typeof cb !== 'function') {
        return promises.reject(new Error('cb must be a function or null to return a Promise'));
    }

    if (!cb) {
        return promises.promise(hash, this, [data, salt]);
    }

    if (data == null || salt == null) {
        error = new Error('data and salt arguments required');
<<<<<<< HEAD
        return process.nextTick(function () {
=======
        return process.nextTick(function() {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
            cb(error);
        });
    }

    if (!(typeof data === 'string' || data instanceof Buffer) || (typeof salt !== 'string' && typeof salt !== 'number')) {
        error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');
<<<<<<< HEAD
        return process.nextTick(function () {
=======
        return process.nextTick(function() {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
            cb(error);
        });
    }


    if (typeof salt === 'number') {
<<<<<<< HEAD
        return module.exports.genSalt(salt, function (err, salt) {
=======
        return module.exports.genSalt(salt, function(err, salt) {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
            return bindings.encrypt(data, salt, cb);
        });
    }

    return bindings.encrypt(data, salt, cb);
<<<<<<< HEAD
}
=======
};
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2

/// compare raw data to hash
/// @param {String|Buffer} data the data to hash and compare
/// @param {String} hash expected hash
/// @return {bool} true if hashed data matches hash
<<<<<<< HEAD
function compareSync(data, hash) {
=======
module.exports.compareSync = function compareSync(data, hash) {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
    if (data == null || hash == null) {
        throw new Error('data and hash arguments required');
    }

    if (!(typeof data === 'string' || data instanceof Buffer) || typeof hash !== 'string') {
        throw new Error('data must be a string or Buffer and hash must be a string');
    }

    return bindings.compare_sync(data, hash);
<<<<<<< HEAD
}
=======
};
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2

/// compare raw data to hash
/// @param {String|Buffer} data the data to hash and compare
/// @param {String} hash expected hash
/// @param {Function} cb callback(err, matched) - matched is true if hashed data matches hash
<<<<<<< HEAD
function compare(data, hash, cb) {
    let error;

    if (typeof data === 'function') {
        error = new Error('data and hash arguments required');
        return process.nextTick(function () {
=======
module.exports.compare = function compare(data, hash, cb) {
    var error;

    if (typeof data === 'function') {
        error = new Error('data and hash arguments required');
        return process.nextTick(function() {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
            data(error);
        });
    }

    if (typeof hash === 'function') {
        error = new Error('data and hash arguments required');
<<<<<<< HEAD
        return process.nextTick(function () {
=======
        return process.nextTick(function() {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
            hash(error);
        });
    }

    // cb exists but is not a function
    // return a rejecting promise
    if (cb && typeof cb !== 'function') {
        return promises.reject(new Error('cb must be a function or null to return a Promise'));
    }

    if (!cb) {
        return promises.promise(compare, this, [data, hash]);
    }

    if (data == null || hash == null) {
        error = new Error('data and hash arguments required');
<<<<<<< HEAD
        return process.nextTick(function () {
=======
        return process.nextTick(function() {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
            cb(error);
        });
    }

    if (!(typeof data === 'string' || data instanceof Buffer) || typeof hash !== 'string') {
        error = new Error('data and hash must be strings');
<<<<<<< HEAD
        return process.nextTick(function () {
=======
        return process.nextTick(function() {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
            cb(error);
        });
    }

    return bindings.compare(data, hash, cb);
<<<<<<< HEAD
}

/// @param {String} hash extract rounds from this hash
/// @return {Number} the number of rounds used to encrypt a given hash
function getRounds(hash) {
=======
};

/// @param {String} hash extract rounds from this hash
/// @return {Number} the number of rounds used to encrypt a given hash
module.exports.getRounds = function getRounds(hash) {
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
    if (hash == null) {
        throw new Error('hash argument required');
    }

    if (typeof hash !== 'string') {
        throw new Error('hash must be a string');
    }

    return bindings.get_rounds(hash);
<<<<<<< HEAD
}

module.exports = {
    genSaltSync,
    genSalt,
    hashSync,
    hash,
    compareSync,
    compare,
    getRounds,
}
=======
};
>>>>>>> b30f922dcacf40c818a525b7880470ca07b11de2
